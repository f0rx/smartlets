// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of metadata;

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$MetadataTearOff {
  const _$MetadataTearOff();

// ignore: unused_element
  _Metadata call(
      {@nullable String fullPath,
      @nullable int size = 0,
      @nullable String contentType,
      @nullable String bucket,
      @nullable String cacheControl,
      @nullable String contentDisposition,
      @nullable String contentEncoding,
      @nullable String contentLanguage,
      @nullable String generation,
      @nullable String md5Hash,
      @nullable String name,
      @nullable String metadataGeneration,
      @nullable Map<String, String> customMetadata,
      @nullable DateTime createdAt,
      @nullable DateTime updatedAt}) {
    return _Metadata(
      fullPath: fullPath,
      size: size,
      contentType: contentType,
      bucket: bucket,
      cacheControl: cacheControl,
      contentDisposition: contentDisposition,
      contentEncoding: contentEncoding,
      contentLanguage: contentLanguage,
      generation: generation,
      md5Hash: md5Hash,
      name: name,
      metadataGeneration: metadataGeneration,
      customMetadata: customMetadata,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $Metadata = _$MetadataTearOff();

/// @nodoc
mixin _$Metadata {
  @nullable
  String get fullPath;
  @nullable
  int get size;
  @nullable
  String get contentType;
  @nullable
  String get bucket;
  @nullable
  String get cacheControl;
  @nullable
  String get contentDisposition;
  @nullable
  String get contentEncoding;
  @nullable
  String get contentLanguage;
  @nullable
  String get generation;
  @nullable
  String get md5Hash;
  @nullable
  String get name;
  @nullable
  String get metadataGeneration;
  @nullable
  Map<String, String> get customMetadata;
  @nullable
  DateTime get createdAt;
  @nullable
  DateTime get updatedAt;

  $MetadataCopyWith<Metadata> get copyWith;
}

/// @nodoc
abstract class $MetadataCopyWith<$Res> {
  factory $MetadataCopyWith(Metadata value, $Res Function(Metadata) then) =
      _$MetadataCopyWithImpl<$Res>;
  $Res call(
      {@nullable String fullPath,
      @nullable int size,
      @nullable String contentType,
      @nullable String bucket,
      @nullable String cacheControl,
      @nullable String contentDisposition,
      @nullable String contentEncoding,
      @nullable String contentLanguage,
      @nullable String generation,
      @nullable String md5Hash,
      @nullable String name,
      @nullable String metadataGeneration,
      @nullable Map<String, String> customMetadata,
      @nullable DateTime createdAt,
      @nullable DateTime updatedAt});
}

/// @nodoc
class _$MetadataCopyWithImpl<$Res> implements $MetadataCopyWith<$Res> {
  _$MetadataCopyWithImpl(this._value, this._then);

  final Metadata _value;
  // ignore: unused_field
  final $Res Function(Metadata) _then;

  @override
  $Res call({
    Object fullPath = freezed,
    Object size = freezed,
    Object contentType = freezed,
    Object bucket = freezed,
    Object cacheControl = freezed,
    Object contentDisposition = freezed,
    Object contentEncoding = freezed,
    Object contentLanguage = freezed,
    Object generation = freezed,
    Object md5Hash = freezed,
    Object name = freezed,
    Object metadataGeneration = freezed,
    Object customMetadata = freezed,
    Object createdAt = freezed,
    Object updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      fullPath: fullPath == freezed ? _value.fullPath : fullPath as String,
      size: size == freezed ? _value.size : size as int,
      contentType:
          contentType == freezed ? _value.contentType : contentType as String,
      bucket: bucket == freezed ? _value.bucket : bucket as String,
      cacheControl: cacheControl == freezed
          ? _value.cacheControl
          : cacheControl as String,
      contentDisposition: contentDisposition == freezed
          ? _value.contentDisposition
          : contentDisposition as String,
      contentEncoding: contentEncoding == freezed
          ? _value.contentEncoding
          : contentEncoding as String,
      contentLanguage: contentLanguage == freezed
          ? _value.contentLanguage
          : contentLanguage as String,
      generation:
          generation == freezed ? _value.generation : generation as String,
      md5Hash: md5Hash == freezed ? _value.md5Hash : md5Hash as String,
      name: name == freezed ? _value.name : name as String,
      metadataGeneration: metadataGeneration == freezed
          ? _value.metadataGeneration
          : metadataGeneration as String,
      customMetadata: customMetadata == freezed
          ? _value.customMetadata
          : customMetadata as Map<String, String>,
      createdAt:
          createdAt == freezed ? _value.createdAt : createdAt as DateTime,
      updatedAt:
          updatedAt == freezed ? _value.updatedAt : updatedAt as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$MetadataCopyWith<$Res> implements $MetadataCopyWith<$Res> {
  factory _$MetadataCopyWith(_Metadata value, $Res Function(_Metadata) then) =
      __$MetadataCopyWithImpl<$Res>;
  @override
  $Res call(
      {@nullable String fullPath,
      @nullable int size,
      @nullable String contentType,
      @nullable String bucket,
      @nullable String cacheControl,
      @nullable String contentDisposition,
      @nullable String contentEncoding,
      @nullable String contentLanguage,
      @nullable String generation,
      @nullable String md5Hash,
      @nullable String name,
      @nullable String metadataGeneration,
      @nullable Map<String, String> customMetadata,
      @nullable DateTime createdAt,
      @nullable DateTime updatedAt});
}

/// @nodoc
class __$MetadataCopyWithImpl<$Res> extends _$MetadataCopyWithImpl<$Res>
    implements _$MetadataCopyWith<$Res> {
  __$MetadataCopyWithImpl(_Metadata _value, $Res Function(_Metadata) _then)
      : super(_value, (v) => _then(v as _Metadata));

  @override
  _Metadata get _value => super._value as _Metadata;

  @override
  $Res call({
    Object fullPath = freezed,
    Object size = freezed,
    Object contentType = freezed,
    Object bucket = freezed,
    Object cacheControl = freezed,
    Object contentDisposition = freezed,
    Object contentEncoding = freezed,
    Object contentLanguage = freezed,
    Object generation = freezed,
    Object md5Hash = freezed,
    Object name = freezed,
    Object metadataGeneration = freezed,
    Object customMetadata = freezed,
    Object createdAt = freezed,
    Object updatedAt = freezed,
  }) {
    return _then(_Metadata(
      fullPath: fullPath == freezed ? _value.fullPath : fullPath as String,
      size: size == freezed ? _value.size : size as int,
      contentType:
          contentType == freezed ? _value.contentType : contentType as String,
      bucket: bucket == freezed ? _value.bucket : bucket as String,
      cacheControl: cacheControl == freezed
          ? _value.cacheControl
          : cacheControl as String,
      contentDisposition: contentDisposition == freezed
          ? _value.contentDisposition
          : contentDisposition as String,
      contentEncoding: contentEncoding == freezed
          ? _value.contentEncoding
          : contentEncoding as String,
      contentLanguage: contentLanguage == freezed
          ? _value.contentLanguage
          : contentLanguage as String,
      generation:
          generation == freezed ? _value.generation : generation as String,
      md5Hash: md5Hash == freezed ? _value.md5Hash : md5Hash as String,
      name: name == freezed ? _value.name : name as String,
      metadataGeneration: metadataGeneration == freezed
          ? _value.metadataGeneration
          : metadataGeneration as String,
      customMetadata: customMetadata == freezed
          ? _value.customMetadata
          : customMetadata as Map<String, String>,
      createdAt:
          createdAt == freezed ? _value.createdAt : createdAt as DateTime,
      updatedAt:
          updatedAt == freezed ? _value.updatedAt : updatedAt as DateTime,
    ));
  }
}

/// @nodoc
class _$_Metadata extends _Metadata {
  const _$_Metadata(
      {@nullable this.fullPath,
      @nullable this.size = 0,
      @nullable this.contentType,
      @nullable this.bucket,
      @nullable this.cacheControl,
      @nullable this.contentDisposition,
      @nullable this.contentEncoding,
      @nullable this.contentLanguage,
      @nullable this.generation,
      @nullable this.md5Hash,
      @nullable this.name,
      @nullable this.metadataGeneration,
      @nullable this.customMetadata,
      @nullable this.createdAt,
      @nullable this.updatedAt})
      : super._();

  @override
  @nullable
  final String fullPath;
  @JsonKey(defaultValue: 0)
  @override
  @nullable
  final int size;
  @override
  @nullable
  final String contentType;
  @override
  @nullable
  final String bucket;
  @override
  @nullable
  final String cacheControl;
  @override
  @nullable
  final String contentDisposition;
  @override
  @nullable
  final String contentEncoding;
  @override
  @nullable
  final String contentLanguage;
  @override
  @nullable
  final String generation;
  @override
  @nullable
  final String md5Hash;
  @override
  @nullable
  final String name;
  @override
  @nullable
  final String metadataGeneration;
  @override
  @nullable
  final Map<String, String> customMetadata;
  @override
  @nullable
  final DateTime createdAt;
  @override
  @nullable
  final DateTime updatedAt;

  @override
  String toString() {
    return 'Metadata(fullPath: $fullPath, size: $size, contentType: $contentType, bucket: $bucket, cacheControl: $cacheControl, contentDisposition: $contentDisposition, contentEncoding: $contentEncoding, contentLanguage: $contentLanguage, generation: $generation, md5Hash: $md5Hash, name: $name, metadataGeneration: $metadataGeneration, customMetadata: $customMetadata, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Metadata &&
            (identical(other.fullPath, fullPath) ||
                const DeepCollectionEquality()
                    .equals(other.fullPath, fullPath)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.bucket, bucket) ||
                const DeepCollectionEquality().equals(other.bucket, bucket)) &&
            (identical(other.cacheControl, cacheControl) ||
                const DeepCollectionEquality()
                    .equals(other.cacheControl, cacheControl)) &&
            (identical(other.contentDisposition, contentDisposition) ||
                const DeepCollectionEquality()
                    .equals(other.contentDisposition, contentDisposition)) &&
            (identical(other.contentEncoding, contentEncoding) ||
                const DeepCollectionEquality()
                    .equals(other.contentEncoding, contentEncoding)) &&
            (identical(other.contentLanguage, contentLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.contentLanguage, contentLanguage)) &&
            (identical(other.generation, generation) ||
                const DeepCollectionEquality()
                    .equals(other.generation, generation)) &&
            (identical(other.md5Hash, md5Hash) ||
                const DeepCollectionEquality()
                    .equals(other.md5Hash, md5Hash)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadataGeneration, metadataGeneration) ||
                const DeepCollectionEquality()
                    .equals(other.metadataGeneration, metadataGeneration)) &&
            (identical(other.customMetadata, customMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.customMetadata, customMetadata)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(fullPath) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(bucket) ^
      const DeepCollectionEquality().hash(cacheControl) ^
      const DeepCollectionEquality().hash(contentDisposition) ^
      const DeepCollectionEquality().hash(contentEncoding) ^
      const DeepCollectionEquality().hash(contentLanguage) ^
      const DeepCollectionEquality().hash(generation) ^
      const DeepCollectionEquality().hash(md5Hash) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadataGeneration) ^
      const DeepCollectionEquality().hash(customMetadata) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt);

  @override
  _$MetadataCopyWith<_Metadata> get copyWith =>
      __$MetadataCopyWithImpl<_Metadata>(this, _$identity);
}

abstract class _Metadata extends Metadata {
  const _Metadata._() : super._();
  const factory _Metadata(
      {@nullable String fullPath,
      @nullable int size,
      @nullable String contentType,
      @nullable String bucket,
      @nullable String cacheControl,
      @nullable String contentDisposition,
      @nullable String contentEncoding,
      @nullable String contentLanguage,
      @nullable String generation,
      @nullable String md5Hash,
      @nullable String name,
      @nullable String metadataGeneration,
      @nullable Map<String, String> customMetadata,
      @nullable DateTime createdAt,
      @nullable DateTime updatedAt}) = _$_Metadata;

  @override
  @nullable
  String get fullPath;
  @override
  @nullable
  int get size;
  @override
  @nullable
  String get contentType;
  @override
  @nullable
  String get bucket;
  @override
  @nullable
  String get cacheControl;
  @override
  @nullable
  String get contentDisposition;
  @override
  @nullable
  String get contentEncoding;
  @override
  @nullable
  String get contentLanguage;
  @override
  @nullable
  String get generation;
  @override
  @nullable
  String get md5Hash;
  @override
  @nullable
  String get name;
  @override
  @nullable
  String get metadataGeneration;
  @override
  @nullable
  Map<String, String> get customMetadata;
  @override
  @nullable
  DateTime get createdAt;
  @override
  @nullable
  DateTime get updatedAt;
  @override
  _$MetadataCopyWith<_Metadata> get copyWith;
}
